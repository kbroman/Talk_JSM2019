// Generated by CoffeeScript 2.4.1
// Interactive lod curve and QTL effect plot

// Click on chromosome in top panel for detailed view below

// In lower-left panel: hover over markers to see names;
// click to view effect plot and phenotype-vs-genotype plot

// In effect plot, hover over means to see values
// In pheno-vs-geno plot, hover over points to see individual ID

// This is awful code; I just barely know what I'm doing.

// function that does all of the work
var draw_lod_and_effect, stop_lod_and_effect;

draw_lod_and_effect = function(data) {
  var XaxisGrp, YaxisGrp, average, bgcolor, bigCircRad, botLw, botRw, botlodcurve, botsvg, bottom, chrColor, chrEnd, chrGap, chrLength, chrPixelEnd, chrPixelStart, chrRect, chrStart, cur, currentMax, curves, darkGray, dotsAtMarkers, effMax, effMin, effectPlot, efftip, g, h, hInner, i, i1, indtip, initialPXG, innerPad, j, j1, jitter, jitterAmount, k, k1, l, l1, labelcolor, lastChr, left, len, len1, len2, len3, len4, len5, len6, lightGray, lo, lod, lodcurve, m, mar, markerClick, markerTicks, martip, maxLod, maxLodByChr, maxLodByChr_marker, me, medCircRad, n, nLabels, nTicks, o, onedig, p, pad, pheMax, pheMin, pink, pos, purple, q, r, randomChr, randomDraw, randomMarker, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, revPXG, right, s, se, sex, smCircRad, svgs, t, tickHeight, title, titlecolor, top, topsvg, totalChrLength, u, up, v, w, wInner, xScale, xlab, xpos, y, yScale, ylab;
  // dimensions of SVG
  w = 1450;
  h = 330;
  botLw = 500;
  pad = {
    left: 60,
    top: 30,
    right: 40,
    bottom: 40
  };
  innerPad = 4;
  wInner = [];
  wInner[0] = w - pad.left - pad.right;
  hInner = [];
  for (i = k = 0; k <= 3; i = ++k) {
    hInner[i] = h - pad.top - pad.bottom;
  }
  chrGap = 8;
  bigCircRad = "4";
  medCircRad = "4";
  smCircRad = "2";
  wInner[1] = botLw - pad.left - pad.right;
  botRw = (w - botLw) / 2;
  wInner[2] = botRw - pad.left - pad.right;
  wInner[3] = wInner[2];
  // left, right, top, bottom positions for each
  // of the four panels
  left = [pad.left, pad.left, botLw + pad.left, botLw + botRw + pad.left];
  right = [];
  for (i = l = 0; l <= 3; i = ++l) {
    right[i] = left[i] + wInner[i];
  }
  top = [];
  bottom = [];
  for (i = n = 0; n <= 3; i = ++n) {
    top[i] = pad.top;
    bottom[i] = pad.top + hInner[i];
  }
  // height of marker ticks in lower-left panel
  tickHeight = (bottom[1] - top[1]) * 0.02;
  // jitter amounts for PXG plot
  jitterAmount = (right[3] - left[3]) / 50;
  jitter = [];
  for (i in data.phevals) {
    jitter[i] = (2.0 * Math.random() - 1.0) * jitterAmount;
  }
  // colors definitions
  bgcolor = "black";
  labelcolor = "white";
  titlecolor = "Wheat";
  lightGray = d3.rgb(200, 200, 200);
  darkGray = d3.rgb(170, 170, 170);
  pink = "#E9CFEC";
  purple = "#8C4374";
  // create SVGs
  topsvg = d3.select("div#lod_and_effect").append("svg").attr("width", w).attr("height", h);
  botsvg = d3.select("div#lod_and_effect").append("svg").attr("width", w).attr("height", h);
  svgs = [topsvg, botsvg, botsvg, botsvg];
// gray backgrounds
  for (j = o = 0; o <= 3; j = ++o) {
    svgs[j].append("rect").attr("x", left[j]).attr("y", top[j]).attr("height", hInner[j]).attr("width", wInner[j]).attr("class", "innerBox");
  }
// for females, swap X chromosome genotypes 1 <-> 2
  for (m in data.markerindex["X"]) {
    ref = data.sex;
    for (i = p = 0, len = ref.length; p < len; i = ++p) {
      sex = ref[i];
      if (sex === 0) {
        data.geno[m][i] = 3 - data.geno[m][i];
      }
    }
  }
  // maximum LOD score
  maxLod = 0;
  ref1 = data.chr;
  for (q = 0, len1 = ref1.length; q < len1; q++) {
    i = ref1[q];
    currentMax = d3.max(data.lod[i].lod);
    if (maxLod < currentMax) {
      maxLod = currentMax;
    }
  }
  // for each chromosome, find the marker with maximum LOD score
  maxLodByChr = {};
  maxLodByChr_marker = {};
  ref2 = data.chr;
  for (r = 0, len2 = ref2.length; r < len2; r++) {
    i = ref2[r];
    maxLodByChr[i] = 0;
    maxLodByChr[i] = "";
    for (m in data.markerindex[i]) {
      lod = data.lod[i].lod[data.markerindex[i][m]];
      if (lod > maxLodByChr[i]) {
        maxLodByChr[i] = lod;
        maxLodByChr_marker[i] = m;
      }
    }
  }
  // maximum effect + SE and minimum effect - SE
  effMax = null;
  effMin = null;
  for (mar in data.effects) {
    for (g in data.effects[mar].Means) {
      for (sex in data.effects[mar].Means[g]) {
        me = data.effects[mar].Means[g][sex];
        se = data.effects[mar].SEs[g][sex];
        if (me !== null) {
          up = me + se;
          lo = me - se;
          if (effMax === null || effMax < up) {
            effMax = up;
          }
          if (effMin === null || effMin > lo) {
            effMin = lo;
          }
        }
      }
    }
  }
  // phenotype max and min
  pheMax = d3.max(data.phevals);
  pheMin = d3.min(data.phevals);
  // start and end of each chromosome
  chrStart = {};
  chrEnd = {};
  chrLength = {};
  totalChrLength = 0;
  ref3 = data.chr;
  for (s = 0, len3 = ref3.length; s < len3; s++) {
    i = ref3[s];
    chrStart[i] = d3.min(data.lod[i].pos);
    chrEnd[i] = d3.max(data.lod[i].pos);
    chrLength[i] = chrEnd[i] - chrStart[i];
    totalChrLength += chrLength[i];
  }
  chrPixelStart = {};
  chrPixelEnd = {};
  cur = Math.round(pad.left + chrGap / 2);
  ref4 = data.chr;
  for (t = 0, len4 = ref4.length; t < len4; t++) {
    i = ref4[t];
    chrPixelStart[i] = cur;
    chrPixelEnd[i] = cur + Math.round((wInner[0] - chrGap * data.chr.length) / totalChrLength * chrLength[i]);
    cur = chrPixelEnd[i] + chrGap;
  }
  // vertical scales
  xScale = [];
  yScale = [];
  yScale[0] = d3.scale.linear().domain([-0.1, maxLod * 1.02]).range([bottom[0], top[0]]);
  yScale[1] = yScale[0];
  // chromosome-specific horizontal scales
  xScale[0] = {};
  xScale[1] = {};
  chrColor = {};
  ref5 = data.chr;
  for (u = 0, len5 = ref5.length; u < len5; u++) {
    i = ref5[u];
    xScale[0][i] = d3.scale.linear().domain([chrStart[i], chrEnd[i]]).range([chrPixelStart[i], chrPixelEnd[i]]);
    xScale[1][i] = d3.scale.linear().domain([0, chrEnd[i]]).range([left[1] + innerPad, right[1] - innerPad]);
    if (i % 2) {
      chrColor[i] = lightGray;
    } else {
      chrColor[i] = darkGray;
    }
  }
  yScale[2] = d3.scale.linear().domain([effMin, effMax]).range([bottom[2] - innerPad, top[2] + innerPad]);
  yScale[3] = d3.scale.linear().domain([pheMin, pheMax]).range([bottom[3] - innerPad, top[3] + innerPad]);
  average = function(x) {
    var len6, sum, v, xv;
    sum = 0;
    for (v = 0, len6 = x.length; v < len6; v++) {
      xv = x[v];
      sum += xv;
    }
    return sum / x.length;
  };
  effectPlot = function(chr, mar) {
    var aves, effplot, femaleloc2, femaleloc3, genotypes, hi, len6, male, maleloc2, maleloc3, mean, ref6, v, y;
    botsvg.selectAll(".effectplot").remove();
    mean = [];
    lo = [];
    hi = [];
    male = [];
    genotypes = [];
    ref6 = ["Female", "Male"];
    for (v = 0, len6 = ref6.length; v < len6; v++) {
      sex = ref6[v];
      for (g in data.effects[mar].Means) {
        me = data.effects[mar].Means[g][sex];
        se = data.effects[mar].SEs[g][sex];
        if (me !== null) {
          mean.push(me);
          lo.push(me - se);
          hi.push(me + se);
          male.push(sex === "Male");
          genotypes.push(g);
        }
      }
    }
    if (chr === "X") {
      genotypes[0] = "BR";
      genotypes[1] = "RR";
    }
    xScale[2] = d3.scale.ordinal().domain(d3.range(mean.length)).rangePoints([left[2], right[2]], 1);
    xScale[3] = d3.scale.ordinal().domain(d3.range(mean.length)).rangePoints([left[3], right[3]], 1);
    femaleloc2 = [];
    femaleloc3 = [];
    maleloc2 = [];
    maleloc3 = [];
    for (i in mean) {
      if (male[i]) {
        maleloc2.push(xScale[2](i));
        maleloc3.push(xScale[3](i));
      } else {
        femaleloc2.push(xScale[2](i));
        femaleloc3.push(xScale[3](i));
      }
    }
    aves = [[average(femaleloc2), average(maleloc2)], [average(femaleloc3), average(maleloc3)]];
// lower middle and lower right X axes
    for (j = y = 2; y <= 3; j = ++y) {
      XaxisGrp[j].selectAll("line").remove();
      XaxisGrp[j].selectAll("text").remove();
      XaxisGrp[j].selectAll("empty").data(d3.range(mean.length)).enter().append("line").attr("y1", top[j]).attr("y2", bottom[j]).attr("x1", function(td) {
        return xScale[j](td);
      }).attr("x2", function(td) {
        return xScale[j](td);
      }).attr("stroke", darkGray).attr("fill", "none").attr("stroke-width", "1");
      XaxisGrp[j].selectAll("empty").data(d3.range(mean.length)).enter().append("text").text(function(td) {
        return genotypes[td];
      }).attr("y", bottom[j] + pad.bottom * 0.25).attr("x", function(td) {
        return xScale[j](td);
      }).attr("fill", labelcolor);
      XaxisGrp[j].selectAll("empty").data(aves[j - 2]).enter().append("text").text(function(td, i) {
        return ["Female", "Male"][i];
      }).attr("fill", titlecolor).attr("y", bottom[j] + pad.bottom * 0.75).attr("x", function(td) {
        return td;
      });
    }
    effplot = botsvg.append("g").attr("id", "effplot");
    effplot.selectAll("empty").data(mean).enter().append("line").attr("class", "effectplot").attr("x1", function(d, i) {
      return xScale[2](i);
    }).attr("x2", function(d, i) {
      return xScale[2](i);
    }).attr("y1", function(d, i) {
      return yScale[2](lo[i]);
    }).attr("y2", function(d, i) {
      return yScale[2](hi[i]);
    }).attr("fill", "none").attr("stroke", "black").attr("stroke-width", "2");
    return effplot.selectAll("empty").data(mean).enter().append("circle").attr("class", "effectplot").attr("cx", function(d, i) {
      return xScale[2](i);
    }).attr("cy", function(d) {
      return yScale[2](d);
    }).attr("r", bigCircRad).attr("fill", function(d, i) {
      if (male[i]) {
        return "darkslateblue";
      }
      return "red";
    }).attr("stroke", "black").attr("stroke-width", "2").on("mouseover", efftip).on("mouseout", function() {
      return d3.selectAll("#efftip").remove();
    });
  };
  // background rectangles for each chromosome, alternate color
  chrRect = topsvg.append("g").attr("id", "chrRect").selectAll("empty").data(data.chr).enter().append("rect").attr("id", function(d) {
    return `rect${d}`;
  }).attr("x", function(d) {
    return chrPixelStart[d] - chrGap / 2;
  }).attr("y", pad.top).attr("width", function(d) {
    return chrPixelEnd[d] - chrPixelStart[d] + chrGap;
  }).attr("height", function(d) {
    return hInner[0];
  }).attr("fill", function(d) {
    return chrColor[d];
  }).attr("stroke", "none");
  // groups to hold all of the xAxis elements
  XaxisGrp = [];
  YaxisGrp = [];
  for (j = v = 0; v <= 3; j = ++v) {
    XaxisGrp[j] = svgs[j].append("g").attr("id", `Xaxis${j}`).attr("class", "axis");
    YaxisGrp[j] = svgs[j].append("g").attr("id", `Yaxis${j}`).attr("class", "axis");
  }
  markerTicks = svgs[1].append("g").attr("id", "markerTickGrp");
  nTicks = [10, 10, 6, 6];
  nLabels = [6, 6, 6, 6];
  for (j = y = 0; y <= 3; j = ++y) {
    YaxisGrp[j].selectAll("empty").data(yScale[j].ticks(nTicks[j])).enter().append("line").attr("y1", function(d) {
      return yScale[j](d);
    }).attr("y2", function(d) {
      return yScale[j](d);
    }).attr("x1", left[j]).attr("x2", right[j]).attr("stroke", "white").attr("fill", "none").attr("stroke-width", "1");
    YaxisGrp[j].selectAll("empty").data(yScale[j].ticks(nLabels[j])).enter().append("text").text(function(d) {
      if (j <= 1) {
        return d;
      }
      return d3.format(".1f")(d);
    }).attr("x", left[j] - pad.left * 0.05).attr("y", function(d) {
      return yScale[j](d);
    }).attr("class", "alignright").attr("fill", labelcolor);
  }
  // y-axis titles
  ylab = ["LOD score", "LOD score", data.phenotype, data.phenotype];
  xpos = [pad.left / 2, pad.left / 2, left[2] - pad.left * 0.6, left[3] - pad.left * 0.7];
  for (j = i1 = 0; i1 <= 3; j = ++i1) {
    YaxisGrp[j].append("text").text(ylab[j]).attr("x", xpos[j]).attr("y", (top[j] + bottom[j]) / 2).attr("fill", titlecolor).attr("transform", `rotate(270,${xpos[j]},${(top[j] + bottom[j]) / 2})`);
  }
  // title on top panel
  topsvg.append("text").text(data.phenotype).attr("x", (left[0] + right[0]) / 2).attr("y", pad.top / 2).attr("fill", titlecolor);
  // x-axis labels
  xlab = ["Chromosome", "Position (cM)"];
  for (j = j1 = 0; j1 <= 1; j = ++j1) {
    XaxisGrp[j].append("text").text(xlab[j]).attr("x", (left[j] + right[j]) / 2).attr("y", bottom[j] + pad.bottom * 0.65).attr("fill", titlecolor);
  }
  // lod curves by chr
  lodcurve = function(j) {
    return d3.svg.line().x(function(d) {
      return xScale[0][j](d);
    }).y(function(d, i) {
      return yScale[0](data.lod[j].lod[i]);
    });
  };
  curves = topsvg.append("g").attr("id", "curves");
  ref6 = data.chr;
  for (k1 = 0, len6 = ref6.length; k1 < len6; k1++) {
    j = ref6[k1];
    curves.append("path").datum(data.lod[j].pos).attr("d", lodcurve(j)).attr("class", "thickline").attr("stroke", "darkslateblue").style("pointer-events", "none");
  }
  // detailed LOD curves below
  botlodcurve = function(j) {
    return d3.svg.line().x(function(d) {
      return xScale[1][j](d);
    }).y(function(d, i) {
      return yScale[1](data.lod[j].lod[i]);
    });
  };
  randomDraw = function(x) {
    return x[Math.floor(Math.random() * x.length)];
  };
  randomChr = "2";
  randomMarker = maxLodByChr_marker[randomChr];
  // initial phenotype vs genotype plot
  initialPXG = function(chr, marker) {
    return botsvg.append("g").attr("id", "plotPXG").selectAll("empty").data(data.phevals).enter().append("circle").attr("class", "plotPXG").attr("cx", function(d, i) {
      var sx;
      g = Math.abs(data.geno[marker][i]);
      sx = data.sex[i];
      if (chr === "X") {
        return xScale[3](sx * 2 + g - 1) + jitter[i];
      }
      return xScale[3](sx * 3 + g - 1) + jitter[i];
    }).attr("cy", function(d) {
      return yScale[3](d);
    }).attr("r", smCircRad).attr("fill", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return pink;
      }
      return darkGray;
    }).attr("stroke", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return purple;
      }
      return "black";
    }).attr("stroke-width", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return "2";
      }
      return "1";
    }).on("mouseover", function(d, i) {
      d3.select(this).attr("r", medCircRad);
      return indtip.call(this, d, i);
    }).on("mouseout", function() {
      d3.selectAll("#indtip").remove();
      return d3.select(this).attr("r", smCircRad);
    });
  };
  // function to revise phenotype vs genotype plot
  revPXG = function(chr, marker) {
    return botsvg.selectAll(".plotPXG").transition().duration(1000).attr("cx", function(d, i) {
      var sx;
      g = Math.abs(data.geno[marker][i]);
      sx = data.sex[i];
      if (chr === "X") {
        return xScale[3](sx * 2 + g - 1) + jitter[i];
      }
      return xScale[3](sx * 3 + g - 1) + jitter[i];
    }).attr("fill", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return pink;
      }
      return darkGray;
    }).attr("stroke", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return purple;
      }
      return "black";
    }).attr("stroke-width", function(d, i) {
      g = data.geno[marker][i];
      if (g < 0) {
        return "2";
      }
      return "1";
    });
  };
  botsvg.append("g").attr("id", "path").append("path").attr("d", botlodcurve(randomChr)(data.lod[randomChr].pos)).attr("class", "thickline").attr("id", "detailedLod").attr("stroke", "darkslateblue").style("pointer-events", "none");
  botsvg.append("text").attr("x", (left[1] + right[1]) / 2).attr("y", pad.top / 2).text(`Chromosome ${randomChr}`).attr("id", "botLtitle").attr("fill", titlecolor);
  botsvg.append("text").attr("x", (left[2] + right[3]) / 2).attr("y", pad.top / 2).text("").attr("id", "botRtitle").attr("fill", titlecolor);
  XaxisGrp[1].selectAll("empty").data(xScale[1][randomChr].ticks(10)).enter().append("line").attr("class", "axis").attr("y1", top[1]).attr("y2", bottom[1]).attr("x1", function(td) {
    return xScale[1][randomChr](td);
  }).attr("x2", function(td) {
    return xScale[1][randomChr](td);
  }).attr("stroke", darkGray).attr("fill", "none").attr("stroke-width", "1");
  XaxisGrp[1].selectAll("empty").data(xScale[1][randomChr].ticks(10)).enter().append("text").attr("class", "axis").text(function(td) {
    return td;
  }).attr("y", bottom[1] + pad.bottom * 0.25).attr("x", function(td) {
    return xScale[1][randomChr](td);
  }).attr("fill", labelcolor);
  onedig = d3.format(".1f");
  // Using https://github.com/Caged/d3-tip
  //   [slightly modified in https://github.com/kbroman/d3-tip]
  martip = d3.svg.tip().orient("right").padding(3).text(function(z) {
    return z;
  }).attr("class", "d3-tip").attr("id", "martip");
  indtip = d3.svg.tip().orient("right").padding(3).text(function(d, i) {
    return data.individuals[i];
  }).attr("class", "d3-tip").attr("id", "indtip");
  efftip = d3.svg.tip().orient("right").padding(3).text(function(d) {
    return d3.format(".2f")(d);
  }).attr("class", "d3-tip").attr("id", "efftip");
  markerClick = [];
  // dots at markers
  dotsAtMarkers = function(chr) {
    var l1, lastMarker, len7, markerCircle, ref7;
    markerClick = {};
    ref7 = data.markers[chr];
    for (l1 = 0, len7 = ref7.length; l1 < len7; l1++) {
      m = ref7[l1];
      markerClick[m] = 0;
    }
    markerClick[randomMarker] = 1;
    lastMarker = "";
    return markerCircle = botsvg.append("g").attr("id", "markerCircle").selectAll("empty").data(data.markers[chr]).enter().append("circle").attr("class", "markercircle").attr("id", function(td) {
      return `circle${td}`;
    }).attr("cx", function(td) {
      return xScale[1][chr](data.lod[chr].pos[data.markerindex[chr][td]]);
    }).attr("cy", function(td) {
      return yScale[1](data.lod[chr].lod[data.markerindex[chr][td]]);
    }).attr("r", bigCircRad).attr("fill", purple).attr("stroke", "none").attr("stroke-width", "2").attr("opacity", 0).on("mouseover", function(td) {
      if (!markerClick[td]) {
        d3.select(this).attr("opacity", 1);
      }
      return martip.call(this, td);
    }).on("mouseout", function(td) {
      d3.select(this).attr("opacity", markerClick[td]);
      return d3.selectAll("#martip").remove();
    }).on("click", function(td) {
      var pos, title;
      pos = data.lod[chr].pos[data.markerindex[chr][td]];
      title = `${td} (chr ${chr}, ${onedig(pos)} cM)`;
      d3.select("text#botRtitle").text(title);
      markerClick[lastMarker] = 0;
      d3.select(`#circle${lastMarker}`).attr("opacity", 0).attr("fill", purple).attr("stroke", "none");
      lastMarker = td;
      markerClick[td] = 1;
      d3.select(this).attr("opacity", 1).attr("fill", pink).attr("stroke", purple);
      effectPlot(chr, td);
      revPXG(chr, td);
      if (randomMarker !== "" && randomMarker !== td) {
        d3.select(`#circle${randomMarker}`).attr("opacity", 0).attr("fill", purple).attr("stroke", "none");
        return randomMarker = "";
      }
    });
  };
  dotsAtMarkers(randomChr);
  markerTicks.selectAll("empty").data(data.markers[randomChr]).enter().append("line").attr("class", "markertick").attr("x1", function(td) {
    var index;
    index = data.markerindex[randomChr][td];
    return xScale[1][randomChr](data.lod[randomChr].pos[index]);
  }).attr("x2", function(td) {
    var index;
    index = data.markerindex[randomChr][td];
    return xScale[1][randomChr](data.lod[randomChr].pos[index]);
  }).attr("y1", bottom[1]).attr("y2", bottom[1] - tickHeight).attr("stroke", "black").attr("stroke-width", "1");
  // Initial "click" of the random marker
  pos = data.lod[randomChr].pos[data.markerindex[randomChr][randomMarker]];
  title = `${randomMarker} (chr ${randomChr}, ${onedig(pos)} cM)`;
  d3.select("text#botRtitle").text(title);
  d3.select(`#circle${randomMarker}`).attr("opacity", 1).attr("fill", pink).attr("stroke", purple);
  effectPlot(randomChr, randomMarker);
  initialPXG(randomChr, randomMarker);
  // select chromosome for lower LOD detailed curve
  lastChr = randomChr;
  topsvg.select(`#rect${randomChr}`).attr("fill", pink);
  chrRect.on("click", function(d) {
    var marker;
    d3.select(this).attr("fill", pink);
    if (lastChr !== d) {
      if (lastChr !== 0) {
        topsvg.select(`#rect${lastChr}`).attr("fill", chrColor[lastChr]);
      }
      lastChr = d;
      botsvg.select("path#detailedLod").attr("d", botlodcurve(d)(data.lod[d].pos));
      botsvg.selectAll("circle.markercircle").remove();
      randomMarker = maxLodByChr_marker[d];
      dotsAtMarkers(d);
      d3.select("text#botLtitle").text(`Chromosome ${d}`);
      XaxisGrp[1].selectAll("line.axis").remove();
      XaxisGrp[1].selectAll("text.axis").remove();
      XaxisGrp[1].selectAll("empty").data(xScale[1][d].ticks(10)).enter().append("line").attr("class", "axis").attr("y1", top[1]).attr("y2", bottom[1]).attr("x1", function(td) {
        return xScale[1][d](td);
      }).attr("x2", function(td) {
        return xScale[1][d](td);
      }).attr("stroke", darkGray).attr("fill", "none").attr("stroke-width", "1");
      XaxisGrp[1].selectAll("empty").data(xScale[1][d].ticks(10)).enter().append("text").attr("class", "axis").text(function(td) {
        return td;
      }).attr("y", bottom[1] + pad.bottom * 0.25).attr("x", function(td) {
        return xScale[1][d](td);
      }).attr("fill", labelcolor);
      markerTicks.selectAll(".markertick").remove();
      markerTicks.selectAll("empty").data(data.markers[d]).enter().append("line").attr("class", "markertick").attr("x1", function(td) {
        var index;
        index = data.markerindex[d][td];
        return xScale[1][d](data.lod[d].pos[index]);
      }).attr("x2", function(td) {
        var index;
        index = data.markerindex[d][td];
        return xScale[1][d](data.lod[d].pos[index]);
      }).attr("y1", bottom[1]).attr("y2", bottom[1] - tickHeight).attr("stroke", "black").attr("stroke-width", "1");
    }
    marker = maxLodByChr_marker[d];
    pos = data.lod[d].pos[data.markerindex[d][marker]];
    title = `${marker} (chr ${d}, ${onedig(pos)} cM)`;
    d3.select("text#botRtitle").text(title);
    d3.select(`#circle${marker}`).attr("opacity", 1).attr("fill", pink).attr("stroke", purple);
    effectPlot(d, marker);
    return revPXG(d, marker);
  });
  // chr labels
  topsvg.append("g").attr("id", "chrLabels").selectAll("empty").data(data.chr).enter().append("text").text(function(d) {
    return d;
  }).attr("x", function(d) {
    return Math.floor((chrPixelStart[d] + chrPixelEnd[d]) / 2);
  }).attr("y", bottom[0] + pad.bottom * 0.3).attr("fill", labelcolor);
// black borders
  results = [];
  for (j = l1 = 0; l1 <= 3; j = ++l1) {
    results.push(svgs[j].append("rect").attr("x", left[j]).attr("y", top[j]).attr("height", hInner[j]).attr("width", wInner[j]).attr("class", "outerBox"));
  }
  return results;
};

stop_lod_and_effect = function() {
  return d3.selectAll("div#lod_and_effect svg").remove();
};
